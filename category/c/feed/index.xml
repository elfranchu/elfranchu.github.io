<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ &#8211; Programando</title>
	<atom:link href="/category/c/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Tutoriales y artículos de programación.</description>
	<lastBuildDate>Wed, 14 Dec 2016 17:10:52 +0000</lastBuildDate>
	<language>es-ES</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.7.6</generator>
<site xmlns="com-wordpress:feed-additions:1">121132704</site>	<item>
		<title>Detección de pupila con visión artificial paso a paso.</title>
		<link>/2016/12/11/deteccion-de-pupila-con-vision-artificial-paso-a-paso/</link>
		<comments>/2016/12/11/deteccion-de-pupila-con-vision-artificial-paso-a-paso/#respond</comments>
		<pubDate>Sun, 11 Dec 2016 16:03:48 +0000</pubDate>
		<dc:creator><![CDATA[fjmenendez]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[OpenCV]]></category>
		<category><![CDATA[Visión Artificial]]></category>

		<guid isPermaLink="false">http://crearpdf.es.anemone.arvixe.com/?p=4</guid>
		<description><![CDATA[Breve introducción a la librería OpenCV Introducción Tras haber aplicado uno de los múltiples algoritmos de detección facial y de detección de ojos que se pueden encontrar realizando una búsqueda en google, vamos a intentar detectar la pupila ocular con la foto de un ojo utilizando la librería de visión artificial OpenCV y Visual Studio. [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Breve introducción a la librería OpenCV</p>
<h3>Introducción</h3>
<div class="blogtext">
<p>Tras haber aplicado uno de los múltiples algoritmos de detección facial y de detección de ojos que se pueden encontrar realizando una búsqueda en google, vamos a intentar detectar la pupila ocular con la foto de un ojo utilizando la librería de visión artificial OpenCV y Visual Studio.</p>
<p><a href="http://opencv.org/">OpenCV, </a> <a href="http://es.wikipedia.org/wiki/OpenCV">http://es.wikipedia.org/wiki/OpenCV</a>  es probablemente la más potente librería de visión artificial. Originalmente desarrollada por Intel y liberada después como software libre bajo licencia GPL, ha evolucionado hasta convertirse en la base de la mayor parte de las aplicaciones de detección de movimiento, reconocimiento facial, detección de objectos, LPR (reconocimiento de matrículas), ..</p>
<table border="0" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td><img src="https://i1.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/imagen.jpg?w=848" alt="" data-recalc-dims="1" /></td>
<td>
<h3><img src="https://i0.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/flechade.jpg?w=848" alt="" data-recalc-dims="1" /></h3>
</td>
<td>
<h3><img src="https://i2.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/resultado.jpg?w=848" alt="" data-recalc-dims="1" /></h3>
</td>
</tr>
</tbody>
</table>
<p>Podéis descargar el código fuente de este ejemplo <a href="http://crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/12/TestOpenCV.zip">aquí</a> o en <a href="https://github.com/elfranchu/deteccion-de-pupila-con-opencv">github</a></p>
<h3>Instalando Visual Studio C++ 2010 Express ® y OpenCV®</h3>
<p>Pues bien, para comenzar esta sencilla aplicación vamos a utilizar Visual Studio.</p>
<p>Si no lo hemos hecho ya, lo primero que debemos hacer es instalar  “Visual Studio C++ 2010” ®, en este caso, y dado que es un proyecto de evaluación hemos instalado la versión gratuita o  Express desde el siguiente enlace  <a href="http://www.visualstudio.com/es-es/downloads/download-visual-studio-vs#DownloadFamilies_2">http://www.visualstudio.com/es-es/downloads/download-visual-studio-vs#DownloadFamilies_2</a></p>
<p><img src="https://i2.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/descarga_visual1.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>He incluido las dlls y librerías de enlazado necesarias para este proyecto en el código fuente, pero no dudéis  en instalar la versión completa.</p>
<p>Para  ello, necesitamos descargar la librería de visión artificial OpenCV <a href="http://docs.opencv.org/trunk/doc/tutorials/introduction/windows_visual_studio_Opencv/windows_visual_studio_Opencv.html#windows-visual-studio-how-to">http://docs.opencv.org/trunk/doc/tutorials/introduction/windows_visual_studio_Opencv/windows_visual_studio_Opencv.html#windows-visual-studio-how-to</a></p>
<p>Al ejecutar el archivo .exe de la descarga para Windows, se descomprimirán los archivos en la ruta deseada, hemos elegido la ruta “D:\Trabajo\OpenCV_Project\”</p>
<p>Podemos descargar el código fuente y los binarios, nosotros en concreto y dado que estamos trabajando con un Windows 7 de 64 bits, utilizaremos las dlls que se encuentran opencv\build\x64\vc10\bin.</p>
<h3>Creando el proyecto</h3>
<p>Tras abrir Visual Studio C++ 2010 Express, elegimos la opción “Crear nueva aplicación de consola de Win32”<br />
<img src="https://i0.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/consola1.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>Es importante, desmarcar la opción encabezado precompilado.</p>
<p><img src="https://i2.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/consola2.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>Debemos indicar donde se encuentran los archivos de encabezado .h, para ello, en las propiedades del proyecto  indicamos “D:\Trabajo\OpenCV_Project\opencv\build\include” como directorio de inclusión adicional.</p>
<p><img src="https://i1.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/consola3.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>&nbsp;</p>
<p>Haremos lo mismo con las bibliotecas incluyendo la ruta “D:\Trabajo\OpenCV_Project\opencv\build\x86\vc10\lib” para resolver la dependencia de biblioteca.</p>
<p><img src="https://i1.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/consola4.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>Añadimos como entrada los archivos opencv_core247d.lib; opencv_imgproc247d.lib; opencv_highgui247d.lib;</p>
<p><img src="https://i2.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/consola5.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>Una vez echo esto, el siguiente código debería compilar</p>
<pre class="cscode"><code><span class="com">// TestOpenCV.cpp: define el punto de entrada de la aplicación de consola.</span>
<span class="com">//</span>

#include <span class="str">"stdafx.h"</span>

#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;iostream&gt;
#include &lt;<span class="key">string</span>.h&gt;

<span class="key">using</span> <span class="key">namespace</span> cv;
 

<span class="key">int</span> main( <span class="key">int</span> argc, <span class="key">char</span>** argv )
{
    
    <span class="key">return</span> 0;
   
}
 </code></pre>
<h3>El algoritmo</h3>
<p><strong>Nuestro objetivo será detectar el borde de la pupila</strong>, es decir obtener un conjunto de puntos que representen ese borde.</p>
<p>Buscaremos rellenar un vector de puntos con el resultado adecuado.</p>
<p>Partiremos de una imagen en disco llamada <em>&#8220;imagen.jpg&#8221;</em> (nombre original verdad?)</p>
<p>El tipo que almacena una imagen en opencv  es &#8220;Mat&#8221;, este tipo de objeto contiene varios campos y métodos públicos bastante obvios de deducir dada su intuitiva nomenclatura iremos detallándolos  según los vayamos utilizando</p>
<p>Para cargar la imagen utilizamos la función &#8220;imread(nombre_fichero_a_cargar, tipo_rgb_gray_&#8230;)&#8221;</p>
<p>Lo primero que debemos hacer es cargar la imagen en memoria para poder tratarla y &#8220;jugar&#8221; con ella.</p>
<pre class="cscode"><code>
 <span class="com">// imagen_color, contendrá la imagen original a tratar</span>
    Mat imagen_color,copia_original;
    Mat imagen_temporal_color;       
    <span class="com">//Leemos el archivo </span>
    imagen_color = imread(nombre_fichero_imagen, IMREAD_COLOR); 
    copia_original= imagen_color.clone();
</code></pre>
<p>&nbsp;</p>
<p><img src="https://i1.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/imagen.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>Las funciones namedWindow e imshow nos permiten mostrar una imagen en pantalla, la primera declara la ventana donde mostrar la imagen decidiendo si el  tamaño de la ventana se puede modificar, la segunda carga la imagen en esa ventana</p>
<pre class="cscode"><code>    
    <span class="com">//Creamos una ventana para mostrar la imagen original</span>
    namedWindow( <span class="str">"Imagen Original"</span>,cv::WINDOW_NORMAL );
    <span class="com">//Mostramos la imagen original</span>
    imshow( <span class="str">"Imagen Original"</span>, imagen_color ); 
	</code>
</pre>
<p>Aplicaremos un filtro Gaussiano con el objetivo de difuminar la imagen  y eliminar posible ruido en los pixeles http://en.wikipedia.org/wiki/Gaussian_blur</p>
<pre class="cscode"><code>
     <span class="com">//Difuminamos para quitar ruido</span>
    GaussianBlur( imagen_color, imagen_color, Size( 3, 3 ), 0, 0 );
</code>
</pre>
<p>&nbsp;</p>
<p>Transformamos a escala de image_grises</p>
<p>&nbsp;</p>
<pre class="cscode"><code>
      cv::cvtColor(imagen_color, image_gris, CV_BGR2GRAY);
</code>
</pre>
<p><img src="https://i2.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/image_gris.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>Aplicamos el umbral para transformar a blanco y negro. La imagen está en escala de grises, es decir, tiene un sólo canal</p>
<p>con valores de 0 a 255, aplicar un umbral será decir que los valores por debajo de un valor pasen a 0 y los valores por encima de ese valor pasen a blanco. Por lo tanto obtendremos una imagen binaria.</p>
<pre class="cscode"><code>
   
   
    <span class="com">//Aplicamos el umbral para transformar a blanco y negro</span>
    cv::threshold(image_gris,image_gris,0.4*sum(image_gris)[0]/(image_gris.cols*image_gris.rows),255,cv::THRESH_BINARY );
    
	</code>
</pre>
<p><img src="https://i1.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/bw.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>&nbsp;</p>
<p>Con las siguientes funciones que obtendremos un  pseudo-histograma horizontal y vertical para detectar la posición del máximo absoluto.</p>
<p>Como hemos visto, tenemos un imagen binaria, los pixeles o bien son negros o bien son blancos.</p>
<p>El histograma horizontal que buscamos es la gráfica del sumatorio de pixeles por columna, realmente es una función f(x) cuyo dominio va de 0 al número de columnas y cuyo valor en cada punto del dominio f(x0), será la suma de los pixels para la columna x0.</p>
<p>Haremos lo mismo con el histograma vertical, suavizaremos la curva obtenida y obtendremos el valor máximo.</p>
<pre class="cscode"><code>
  
<span class="key">void</span> SuavizaCurva(vector&lt;<span class="key">int</span>&gt;&amp;suma_negros_columnas);
vector&lt;<span class="key">int</span>&gt;  DameHistogramaHorizontal(<span class="key">const</span> Mat &amp; gray);
vector&lt;<span class="key">int</span>&gt;  DameHistogramaVertical(<span class="key">const</span> Mat &amp; gray);
<span class="key">int</span> DamePosicionDelMaximo(vector&lt;<span class="key">int</span>&gt; suma_negros_columnas);
<span class="key">int</span> DamePuntoSuperiorMaximo(vector&lt;<span class="key">int</span>&gt; suma_negros_columnas, <span class="key">int</span> umbral);
<span class="key">int</span> DamePuntoInferiorMaximo(vector&lt;<span class="key">int</span>&gt; suma_negros_columnas, <span class="key">int</span> umbral);

	</code>
</pre>
<p>Podemos mostrar la proyección de pixels que hemos calculado.</p>
<pre class="cscode"><code>
	<span class="com">//Mostramos la proyección de pixels </span>
    <span class="key">for</span>(<span class="key">int</span> i=0;i&lt;image_gris.cols;i++)
    { 
        cv::line(imagen_temporal_color,cv::Point(i,0),cv::Point(i,suma_negros_columnas[i]),Scalar(0,0,255), 3, 8, 0 );
    }
	  <span class="key">for</span>(<span class="key">int</span> i=0;i&lt;image_gris.rows;i++)
    { 
        cv::line(imagen_temporal_color,cv::Point(0,i),cv::Point(suma_negros_filas[i],i),Scalar(255,0,0), 3, 8, 0 );
    }
	
	</code>
</pre>
<p><img src="https://i2.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/imagen_temporal_color.jpg?w=848" alt="" data-recalc-dims="1" /></p>
<p>Como podemos observar, hay un conjunto de puntos que acompañan al máximo, que destacan sobre el resto de la gráfica y que pertenecerán al conjunto de puntos buscado.</p>
<p>Una vez que hemos detectado la posible zona de ubicación de la pupila, nos queda recortar esta zona aplicar el agoritmo de detección de bordes de  Canny  http://es.wikipedia.org/wiki/Algoritmo_de_Canny   y mostraremos los resultados</p>
<p>&nbsp;</p>
<pre class="cscode"><code>
 
 recorte_color=copia_original(cv::Rect(x_0 -dx   ,y_0-dy , (x_1-x_0 +2*dx) ,(y_1-y_0 +2*dy)  ) ).clone();
    namedWindow( <span class="str">"recorte_color"</span>,cv::WINDOW_NORMAL );
    imshow( <span class="str">"recorte_color"</span>, recorte_color ); 
    Mat recorte_gris;
            cv::imwrite(<span class="str">"recorte_color.jpg"</span>,recorte_color);
    cv::cvtColor(recorte_color,recorte_gris, CV_BGR2GRAY);
     
    namedWindow( <span class="str">"recorte_gris"</span>,cv::WINDOW_NORMAL );
    imshow( <span class="str">"recorte_gris"</span>, recorte_gris );  
    cv::imwrite(<span class="str">"recorte_gris.jpg"</span>,recorte_gris);
    <span class="com">//Difuminamos la imagen</span>
    blur( recorte_gris, matriz_deteccion, Size(3,3) );
    <span class="com">//Aplicamos el algoritmo de detección de bordes de Canny</span>
    <span class="com">//http://es.wikipedia.org/wiki/Algoritmo_de_Canny</span>
	
	
	
   Canny( matriz_deteccion, matriz_deteccion, 30, 180, 3 );
    
	 <span class="com">//Invertimos los colores</span>
    bitwise_not(matriz_deteccion,matriz_deteccion);
    <span class="com">//Aplicamos una erosión </span>
    cv::erode(matriz_deteccion,matriz_deteccion,Mat());

    namedWindow( <span class="str">"Canny"</span>, WINDOW_NORMAL );
    imshow( <span class="str">"Canny"</span>, matriz_deteccion );
    cv::imwrite(<span class="str">"Canny.jpg"</span>,matriz_deteccion);
     <span class="com">// Mostramos los bordes detectados en el recorte</span>
    Mat  dst =   Mat(recorte_color.size(),recorte_color.type(),Scalar::all(255));<span class="com">//.clone();</span>
    recorte_color.copyTo( dst, matriz_deteccion);
    namedWindow( <span class="str">"detección"</span>, WINDOW_NORMAL );
    imshow( <span class="str">"detección"</span>, dst );
   cv::imwrite(<span class="str">"dst.jpg"</span>,dst);
    <span class="com">//Llenamos el vector de puntos que estabamos buscando</span>
    <span class="key">for</span>(<span class="key">int</span> i=0;i&lt;matriz_deteccion.cols ;i++)
    {
        <span class="key">for</span>(<span class="key">int</span> j=0;j&lt;matriz_deteccion.rows;j++)
        {
            <span class="com">//Hay que tener en cuenta que los puntos detectados están en el recorte</span>
            <span class="com">//Por eso, habrá que sumarles los desplazamientos</span>
            <span class="key">if</span>(matriz_deteccion.at&lt;uchar&gt;(cv::Point(i,j))==0)
                vector_puntos.push_back(cv::Point(i+x_0 -dx ,j+y_0-dy ));
        }
    } 
    <span class="com">//Mostramos el resultado</span>
    <span class="key">for</span>(<span class="key">int</span> i=0;i&lt;vector_puntos.size() ;i++)
    {
        cv::circle(copia_original,vector_puntos[i],0.1,cv::Scalar(255,0,0),0.1);
    } 
    namedWindow( <span class="str">"resultado"</span>, WINDOW_NORMAL );
    imshow( <span class="str">"resultado"</span>, copia_original );
	</code>
</pre>
<p>&nbsp;</p>
<p>Por último mostramos el resultado</p>
<p><img src="https://i2.wp.com/crearpdf.es.anemone.arvixe.com/wp-content/uploads/2016/11/resultado.jpg?w=848" alt="" data-recalc-dims="1" /></p>
</div>
<div class="blogdate"><span id="ctl00_mainContent_ctl00_postList_rptBlogs_ctl00_spnAuthor" class="blogauthor">Publicado por Admin</span> <span id="ctl00_mainContent_ctl00_postList_rptBlogs_ctl00_spnBottomDate" class="bdate">jueves, 20 de febrero de 2014 14:25:00</span></div>
]]></content:encoded>
			<wfw:commentRss>/2016/12/11/deteccion-de-pupila-con-vision-artificial-paso-a-paso/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">4</post-id>	</item>
	</channel>
</rss>

<!-- Dynamic page generated in 0.283 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2017-10-07 17:53:44 -->
